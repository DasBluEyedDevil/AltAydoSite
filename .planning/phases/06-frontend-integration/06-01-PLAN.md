---
phase: 06-frontend-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useShipBatch.ts
  - src/hooks/useOrgFleet.ts
  - src/lib/ships/mappers.ts
autonomous: true

must_haves:
  truths:
    - "useShipBatch resolves an array of fleetyardsIds to a Map of ShipDocuments via /api/ships/batch"
    - "useShipBatch handles empty/invalid IDs gracefully (returns empty Map)"
    - "useShipBatch chunks requests into batches of 50 to respect API limit"
    - "useOrgFleet fetches all users, collects their ships, and batch-resolves to ShipDocuments"
    - "shipDocumentToUserShip and shipDocumentToMissionShip produce correctly shaped objects"
  artifacts:
    - path: "src/hooks/useShipBatch.ts"
      provides: "Batch ship resolution hook"
      exports: ["useShipBatch"]
    - path: "src/hooks/useOrgFleet.ts"
      provides: "Org fleet aggregation hook"
      exports: ["useOrgFleet"]
    - path: "src/lib/ships/mappers.ts"
      provides: "ShipDocument-to-UserShip and ShipDocument-to-MissionShip mapping helpers"
      exports: ["shipDocumentToUserShip", "shipDocumentToMissionShip"]
  key_links:
    - from: "src/hooks/useShipBatch.ts"
      to: "/api/ships/batch"
      via: "POST fetch with chunking"
      pattern: "fetch.*api/ships/batch"
    - from: "src/hooks/useOrgFleet.ts"
      to: "/api/users"
      via: "GET fetch with pagination"
      pattern: "fetch.*api/users"
    - from: "src/lib/ships/mappers.ts"
      to: "src/lib/ships/image.ts"
      via: "resolveShipImage import"
      pattern: "resolveShipImage"
---

<objective>
Create the foundation hooks and mapping utilities that all other Phase 6 plans depend on.

Purpose: Every INT requirement needs either batch ship resolution (useShipBatch), org fleet aggregation (useOrgFleet), or ShipDocument-to-domain-type mappers. Building these first enables all downstream plans to run in parallel.

Output: Three new files -- useShipBatch hook, useOrgFleet hook, and mappers utility module. Plus install recharts for Plan 05.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hooks/useShips.ts
@src/hooks/useShipDetail.ts
@src/types/ship.ts
@src/types/user.ts
@src/types/PlannedMission.ts
@src/types/Mission.ts
@src/lib/ships/image.ts
@src/app/api/ships/batch/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useShipBatch hook and mapping utilities</name>
  <files>src/hooks/useShipBatch.ts, src/lib/ships/mappers.ts</files>
  <action>
Create `src/hooks/useShipBatch.ts`:
- 'use client' directive at top
- Export function `useShipBatch(ids: string[])` returning `{ ships: Map<string, ShipDocument>; isLoading: boolean; error: string | null }`
- Filter out empty strings and deduplicate IDs before fetching
- If no valid IDs, return empty Map immediately (no fetch)
- Chunk valid IDs into arrays of 50 (the batch API limit from POST /api/ships/batch Zod validation: `z.array(z.string().uuid()).min(1).max(50)`)
- Fetch each chunk sequentially via POST /api/ships/batch with `{ ids: chunk }`
- Use AbortController (matching pattern from useShips hook) -- abort on unmount and when IDs change
- Build Map<fleetyardsId, ShipDocument> from merged results
- Use `[ids.join(',')]` as useEffect dependency for stable comparison (matching research recommendation)
- Handle AbortError silently (return without state update)
- Import ShipDocument as type-only: `import type { ShipDocument } from '@/types/ship'`

Create `src/lib/ships/mappers.ts`:
- Import `resolveShipImage` from `@/lib/ships/image` and types from `@/types/ship`, `@/types/user`, `@/types/PlannedMission`
- Export `shipDocumentToUserShip(ship: ShipDocument): UserShip`:
  ```
  { manufacturer: ship.manufacturer.name, name: ship.name, fleetyardsId: ship.fleetyardsId, image: resolveShipImage(ship.images, 'store') }
  ```
- Export `shipDocumentToMissionShip(ship: ShipDocument, quantity?: number): MissionShip`:
  ```
  { shipName: ship.name, manufacturer: ship.manufacturer.name, size: ship.size || 'medium', role: ship.classification ? [ship.classificationLabel] : [], fleetyardsId: ship.fleetyardsId, image: resolveShipImage(ship.images, 'store'), quantity: quantity ?? 1, notes: '' }
  ```
- These mappers address Pitfall 4 (UserShip type mismatch) and Pitfall 5 (empty fleetyardsId placeholder) from research.
  </action>
  <verify>Run `npm run type-check` -- no new type errors. Verify files exist and exports are correct.</verify>
  <done>useShipBatch hook exports correctly typed function. mappers.ts exports both mapping functions. Type-check passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create useOrgFleet hook and install recharts</name>
  <files>src/hooks/useOrgFleet.ts, package.json</files>
  <action>
Run `npm install recharts` to add the charting library needed by Plan 05 (INT-06).

Create `src/hooks/useOrgFleet.ts`:
- 'use client' directive at top
- Import type ShipDocument from '@/types/ship' (type-only)
- Define aggregation types locally in the file:
  ```typescript
  export interface FleetAggregation {
    byClassification: CategoryCount[];
    byManufacturer: CategoryCount[];
    bySize: CategoryCount[];
    totalShips: number;
    totalMembers: number;
    shipDetails: Map<string, { ship: ShipDocument; count: number }>;
  }
  export interface CategoryCount {
    name: string;
    count: number;
    ships: { name: string; count: number }[];
  }
  ```
- Export function `useOrgFleet()` returning `{ data: FleetAggregation | null; isLoading: boolean; error: string | null }`
- On mount, fetch all users via GET /api/users, paginating if needed (iterate pages until page >= totalPages)
- Collect all unique fleetyardsIds from all users' ships arrays
- Filter out empty strings
- Batch-resolve via POST /api/ships/batch (chunk into 50s, same pattern as useShipBatch)
- For each user's ship with a resolved ShipDocument:
  - Aggregate by `ship.classificationLabel` (or 'Unclassified' if empty)
  - Aggregate by `ship.manufacturer.name`
  - Aggregate by `ship.size` (or 'Unknown' if empty)
  - Track individual ship model counts within each category for drill-down
- Use AbortController for cleanup
- Sort each aggregation by count descending
  </action>
  <verify>Run `npm run type-check` -- no new type errors. Verify recharts is in package.json dependencies. Verify useOrgFleet.ts exists with correct exports.</verify>
  <done>recharts installed. useOrgFleet hook fetches users, resolves ships, and produces FleetAggregation with three axes of breakdown. Type-check passes.</done>
</task>

</tasks>

<verification>
- `npm run type-check` passes with zero new errors
- `src/hooks/useShipBatch.ts` exists and exports `useShipBatch`
- `src/hooks/useOrgFleet.ts` exists and exports `useOrgFleet`, `FleetAggregation`, `CategoryCount`
- `src/lib/ships/mappers.ts` exists and exports `shipDocumentToUserShip`, `shipDocumentToMissionShip`
- `recharts` appears in package.json dependencies
</verification>

<success_criteria>
All three new modules type-check cleanly. recharts is installed. Foundation is ready for Plans 02-05.
</success_criteria>

<output>
After completion, create `.planning/phases/06-frontend-integration/06-01-SUMMARY.md`
</output>
