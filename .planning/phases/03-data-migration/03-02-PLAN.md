---
phase: 03-data-migration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/scripts/migrate-ship-references.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Running the migration script updates user.ships[] entries with fleetyardsId fields"
    - "Running the migration script updates mission.participants[] entries that have shipName with fleetyardsId fields"
    - "Running the migration script updates plannedMission.ships[] entries with fleetyardsId fields"
    - "Running the migration script updates operations.json participant entries with fleetyardsId fields"
    - "Running the migration script updates resources.json entries of type Ship with fleetyardsId fields"
    - "Running the migration a second time produces no changes (idempotent)"
    - "A migration report is printed showing every name-to-UUID mapping with the strategy used"
    - "Any unmatched names are reported in the output, not silently dropped"
    - "The --dry-run flag shows what would change without writing anything"
  artifacts:
    - path: "src/scripts/migrate-ship-references.ts"
      provides: "Main migration script for all collections"
      min_lines: 200
    - path: "package.json"
      provides: "npm run migrate-ships script entry"
      contains: "migrate-ships"
  key_links:
    - from: "src/scripts/migrate-ship-references.ts"
      to: "src/lib/ship-name-matcher.ts"
      via: "import resolveShipName, buildShipsIndex, UUID_REGEX, MANUAL_OVERRIDES"
      pattern: "import.*ship-name-matcher"
    - from: "src/scripts/migrate-ship-references.ts"
      to: "src/lib/user-storage.ts"
      via: "getAllUsers, updateUser for user migration"
      pattern: "import.*user-storage"
    - from: "src/scripts/migrate-ship-references.ts"
      to: "src/lib/mongodb.ts"
      via: "connectToDatabase for missions and planned-missions collections"
      pattern: "connectToDatabase"
    - from: "src/scripts/migrate-ship-references.ts"
      to: "data/operations.json"
      via: "fs read/write for local JSON operations"
      pattern: "operations\\.json"
    - from: "src/scripts/migrate-ship-references.ts"
      to: "data/resources.json"
      via: "fs read/write for local JSON resources"
      pattern: "resources\\.json"
---

<objective>
Build the migration script that converts all ship references across five entity types (users, missions, operations, resources, planned missions) from name strings to FleetYards UUIDs.

Purpose: This is the core deliverable of Phase 3. After running this script, every ship reference in the system will have a `fleetyardsId` field that resolves to a valid ship document in the `ships` collection, enabling the Phase 4 type system pivot from name-based to UUID-based references.

Output: `src/scripts/migrate-ship-references.ts` (runnable via `npm run migrate-ships`) that migrates all five collections and prints a comprehensive report.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-migration/03-RESEARCH.md
@.planning/phases/03-data-migration/03-01-SUMMARY.md

Key source files:
@src/lib/ship-name-matcher.ts (resolveShipName, buildShipsIndex, UUID_REGEX -- created in Plan 01)
@src/lib/user-storage.ts (getAllUsers, updateUser -- handles MongoDB/local fallback)
@src/lib/mongodb.ts (connectToDatabase returns { client, db })
@src/lib/mission-storage.ts (pattern for direct MongoDB access to missions collection)
@src/lib/planned-mission-storage.ts (pattern for direct MongoDB access to planned-missions collection)
@src/lib/operation-storage.ts (local JSON pattern for operations)
@src/lib/resource-storage.ts (local JSON pattern for resources)
@src/scripts/migrate-timezone.ts (existing migration script pattern to follow)
@src/types/user.ts (UserShip type)
@src/types/Mission.ts (MissionParticipant type)
@src/types/Operation.ts (OperationParticipant type)
@src/types/Resource.ts (Resource type)
@src/types/PlannedMission.ts (MissionShip type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration script with all five collection handlers</name>
  <files>src/scripts/migrate-ship-references.ts</files>
  <action>
Create `src/scripts/migrate-ship-references.ts` following the pattern of `migrate-timezone.ts`.

**Command-line argument handling:**
- Parse `process.argv` for a `--dry-run` flag. When present, log all planned changes but do NOT write to any storage.
- Log the mode at startup: `"MIGRATION: Running in DRY-RUN mode (no writes)"` or `"MIGRATION: Running in LIVE mode"`

**Report type:**
```typescript
interface CollectionReport {
  total: number;
  updated: number;
  skipped: number;   // already migrated or no ships
  failed: number;
}

interface MigrationMapping {
  collection: string;
  documentId: string;
  fieldPath: string;     // e.g., "ships[0].name", "participants[2].shipName"
  originalName: string;
  resolvedName: string;
  fleetyardsId: string;
  strategy: string;
}

interface UnmatchedEntry {
  collection: string;
  documentId: string;
  fieldPath: string;
  name: string;
}

interface MigrationReport {
  startedAt: string;
  completedAt?: string;
  dryRun: boolean;
  collections: Record<string, CollectionReport>;
  mappings: MigrationMapping[];
  unmatchedNames: UnmatchedEntry[];
  totalProcessed: number;
  totalUpdated: number;
  totalSkipped: number;
  totalFailed: number;
}
```

**`main()` function:**
1. Parse `--dry-run` from process.argv
2. Call `buildShipsIndex()` from `ship-name-matcher.ts` to load the ships lookup
3. Log the number of ships loaded: `"MIGRATION: Loaded {N} ships into lookup index"`
4. Initialize the MigrationReport
5. Run each collection migration sequentially:
   - `await migrateUserShips(index, report, dryRun)`
   - `await migrateMissions(index, report, dryRun)`
   - `await migratePlannedMissions(index, report, dryRun)`
   - `await migrateOperations(index, report, dryRun)`
   - `await migrateResources(index, report, dryRun)`
6. Set `report.completedAt` and compute totals
7. Call `printReport(report)`
8. Exit with code 0 if no unmatched names, code 1 if any unmatched names remain

**`migrateUserShips(index, report, dryRun)`:**
- Import `getAllUsers` and `updateUser` from `../lib/user-storage`
- Get all users via `getAllUsers()`
- For each user with `ships` array:
  - For each ship in `user.ships[]`:
    - Check if `(ship as any).fleetyardsId` exists and passes `UUID_REGEX.test()` -- if so, skip (already migrated)
    - Call `resolveShipName(ship.name, index)` to get the match
    - If matched: record in `report.mappings`, set `fleetyardsId` on the ship object
    - If not matched: record in `report.unmatchedNames`
  - If any ships were updated and NOT dryRun: call `updateUser(user.id, { ships: migratedShips })`
- Record collection stats in `report.collections.users`

**`migrateMissions(index, report, dryRun)`:**
- Use `connectToDatabase()` from `@/lib/mongodb` to get `{ db }`
- Query `db.collection('missions').find({}).toArray()`
- For each mission with `participants` array:
  - For each participant that has a `shipName`:
    - Check if `(participant as any).fleetyardsId` exists and is valid UUID -- skip if so
    - Call `resolveShipName(participant.shipName, index)`
    - If matched: record mapping
    - If not matched: record unmatched
  - If any participants updated and NOT dryRun: use `db.collection('missions').updateOne({ id: mission.id }, { $set: { participants: updatedParticipants } })`
- Record stats in `report.collections.missions`

**`migratePlannedMissions(index, report, dryRun)`:**
- Same pattern as missions but against `db.collection('planned-missions')`
- Iterate `plannedMission.ships[]` (MissionShip array)
- For each ship entry with `shipName`:
  - Check if `(ship as any).fleetyardsId` exists and is valid UUID
  - Call `resolveShipName(ship.shipName, index)`
  - Record mapping or unmatched
- If updated and NOT dryRun: `db.collection('planned-missions').updateOne({ id: mission.id }, { $set: { ships: updatedShips } })`
- Record stats in `report.collections.plannedMissions`

**`migrateOperations(index, report, dryRun)`:**
- Read `data/operations.json` using `fs.readFileSync` + `JSON.parse`
- If empty array, log and skip
- For each operation with `participants` array:
  - For each participant with `shipName`:
    - Check if `(participant as any).fleetyardsId` exists and is valid UUID
    - Call `resolveShipName(participant.shipName, index)`
    - Record mapping or unmatched
- If any updated and NOT dryRun: write back with `fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8')`
- Record stats in `report.collections.operations`

**`migrateResources(index, report, dryRun)`:**
- Read `data/resources.json` using `fs.readFileSync` + `JSON.parse`
- If empty array, log and skip
- For each resource where `resource.type === 'Ship'`:
  - Check if `(resource as any).fleetyardsId` exists and is valid UUID
  - Call `resolveShipName(resource.name, index)`
  - Record mapping or unmatched
- If any updated and NOT dryRun: write back with `fs.writeFileSync`
- Record stats in `report.collections.resources`

**`printReport(report)`:**
Print a structured report to console:
```
========================================
SHIP REFERENCE MIGRATION REPORT
========================================
Mode: DRY-RUN | LIVE
Started: {timestamp}
Completed: {timestamp}
Duration: {seconds}s

--- Collection Summary ---
Users:           {total} total, {updated} updated, {skipped} skipped, {failed} failed
Missions:        {total} total, ...
Planned Missions: {total} total, ...
Operations:      {total} total, ...
Resources:       {total} total, ...

--- Totals ---
Total documents: {N}
Total updated:   {N}
Total skipped:   {N}
Total failed:    {N}

--- Name Mappings ({N} total) ---
[collection] doc:{id} {fieldPath}: "{originalName}" -> "{resolvedName}" ({strategy})
...

--- Unmatched Names ({N} total) ---
[collection] doc:{id} {fieldPath}: "{name}" -- NO MATCH FOUND
...

========================================
RESULT: {SUCCESS (0 unmatched) | PARTIAL ({N} unmatched names)}
========================================
```

**Critical constraints:**
- Do NOT remove any existing fields (name, shipName, manufacturer, image, etc.) -- ONLY ADD `fleetyardsId`
- Do NOT use bulk operations -- update one document at a time with try/catch
- Use `connectToDatabase` from `@/lib/mongodb` (returns `{ client, db }`)
- Use `user-storage.ts` API for users (handles MongoDB/local fallback automatically)
- Use direct fs for operations.json and resources.json
- Wrap the `if (require.main === module)` guard around `main()` call
- Export `main` function for potential programmatic use
- Use relative imports for local modules: `'../lib/user-storage'`, `'../lib/ship-name-matcher'`, `'../lib/mongodb'`

**Path alias handling:**
The script uses `@/` path aliases. Check package.json for how existing migration scripts are run. The current pattern uses `tsx` which supports tsconfig paths automatically. Use the same approach.
  </action>
  <verify>
Run `npm run type-check` -- zero errors.
Verify key patterns:
- `grep "import.*buildShipsIndex" src/scripts/migrate-ship-references.ts` -- imports from ship-name-matcher
- `grep "import.*user-storage" src/scripts/migrate-ship-references.ts` -- imports getAllUsers/updateUser
- `grep "connectToDatabase" src/scripts/migrate-ship-references.ts` -- uses mongodb.ts
- `grep "dry-run\|dryRun\|dry_run" src/scripts/migrate-ship-references.ts` -- has dry-run support
- `grep "fleetyardsId" src/scripts/migrate-ship-references.ts` -- adds fleetyardsId field
- `grep "operations.json" src/scripts/migrate-ship-references.ts` -- handles local JSON
- `grep "resources.json" src/scripts/migrate-ship-references.ts` -- handles local JSON
- `grep "planned-missions" src/scripts/migrate-ship-references.ts` -- handles planned missions collection
- `grep "UUID_REGEX" src/scripts/migrate-ship-references.ts` -- idempotency check
- `grep "require.main" src/scripts/migrate-ship-references.ts` -- has module guard
- Verify the script does NOT contain "deleteField", "unset", "$unset", or "delete ship.name" (must not remove existing fields)
  </verify>
  <done>
Migration script exists at `src/scripts/migrate-ship-references.ts` with handlers for all 5 collections (users, missions, planned missions, operations, resources). Supports `--dry-run` flag. Type-check passes. Does not remove any existing fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add npm script and verify type-check</name>
  <files>package.json</files>
  <action>
Add a `migrate-ships` script entry to `package.json` scripts section, following the pattern of the existing migration scripts:

```json
"migrate-ships": "tsx src/scripts/migrate-ship-references.ts"
```

Place it adjacent to the other migrate-* scripts (`migrate-users`, `migrate-timezone`).

The `tsx` runner (already used by `migrate-users` and `migrate-timezone`) handles TypeScript execution and tsconfig path alias resolution automatically.
  </action>
  <verify>
- `grep "migrate-ships" package.json` -- script entry exists
- `npm run type-check` -- zero errors (entire project including the new script)
  </verify>
  <done>
`npm run migrate-ships` is a valid script that runs the migration. `npm run migrate-ships -- --dry-run` runs in dry-run mode. Type-check passes for the entire project.
  </done>
</task>

</tasks>

<verification>
- `npm run type-check` passes with zero errors
- `src/scripts/migrate-ship-references.ts` handles all 5 collection types
- Script imports from `ship-name-matcher.ts` (Plan 01 output)
- Script uses `user-storage.ts` for users (handles MongoDB/local fallback)
- Script uses `connectToDatabase` from `mongodb.ts` for missions and planned missions
- Script uses `fs` for operations.json and resources.json
- `--dry-run` flag prevents all writes
- Idempotency: documents with existing valid `fleetyardsId` are skipped
- No existing fields are removed (only `fleetyardsId` is added)
- Migration report prints all mappings with strategies
- Unmatched names are reported, not silently dropped
- `package.json` has `migrate-ships` script entry
</verification>

<success_criteria>
- MIG-01: User ship references get `fleetyardsId` via `migrateUserShips` function
- MIG-02: Mission participant ship references get `fleetyardsId` via `migrateMissions` and `migratePlannedMissions` functions
- MIG-03: Operation participant ship references get `fleetyardsId` via `migrateOperations` function
- MIG-04: Resource records of type Ship get `fleetyardsId` via `migrateResources` function
- MIG-05: Multi-pass name matching via `resolveShipName` from Plan 01 (manual-override, exact, case-insensitive, slug, contains)
- MIG-06: Idempotent -- `UUID_REGEX.test(fleetyardsId)` check skips already-migrated documents
- Migration report printed with all mappings and strategies
- `npm run migrate-ships` and `npm run migrate-ships -- --dry-run` are valid commands
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-migration/03-02-SUMMARY.md`
</output>
