---
phase: 03-data-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ship-name-matcher.ts
autonomous: true

must_haves:
  truths:
    - "Given a codebase ship name that exactly matches a FleetYards name, the matcher returns the FleetYards UUID with strategy 'exact'"
    - "Given a known misspelling like 'F8C Lightening', the manual override map returns the correct FleetYards UUID"
    - "Given 'Ares Star Fighter Inferno', the manual override map returns the Ares Inferno UUID"
    - "Given a name with only case differences, the matcher returns a match with strategy 'case-insensitive'"
    - "Given a slug-convertible name, the matcher returns a match with strategy 'slug'"
    - "Given a completely unknown name, the matcher returns null"
    - "Every known codebase-to-FleetYards name discrepancy from research has a manual override entry"
  artifacts:
    - path: "src/lib/ship-name-matcher.ts"
      provides: "Multi-pass ship name matching engine with manual override map"
      exports: ["resolveShipName", "buildShipsIndex", "MANUAL_OVERRIDES", "ShipsIndex", "MatchResult", "MatchStrategy"]
      min_lines: 100
  key_links:
    - from: "src/lib/ship-name-matcher.ts"
      to: "src/lib/mongodb.ts"
      via: "connectToDatabase for loading ships collection"
      pattern: "connectToDatabase"
    - from: "src/lib/ship-name-matcher.ts"
      to: "ships collection"
      via: "db.collection('ships').find()"
      pattern: "collection.*ships"
---

<objective>
Build the reusable ship name matching engine that resolves codebase ship names to FleetYards UUIDs using a multi-pass strategy.

Purpose: This is the foundational module for the entire migration. Every collection migration function will call `resolveShipName()` to convert name strings to UUIDs. Getting the matching logic right (especially the manual override map for known discrepancies) is critical to achieving the 100% match rate success criterion.

Output: `src/lib/ship-name-matcher.ts` -- a standalone module exporting `buildShipsIndex()` (loads ships from MongoDB into in-memory lookup maps) and `resolveShipName()` (multi-pass matcher with configurable override map).
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-migration/03-RESEARCH.md

Key source files:
@src/lib/ship-storage.ts (UUID_REGEX pattern, connectToDatabase import pattern)
@src/lib/mongodb.ts (connectToDatabase returns { client, db })
@src/types/ship.ts (ShipDocument type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ship-name-matcher.ts with multi-pass resolution engine</name>
  <files>src/lib/ship-name-matcher.ts</files>
  <action>
Create `src/lib/ship-name-matcher.ts` with the following exports:

**Types:**
```typescript
type MatchStrategy = 'manual-override' | 'exact' | 'case-insensitive' | 'slug' | 'contains';

interface MatchResult {
  fleetyardsId: string;
  matchedName: string;
  strategy: MatchStrategy;
}

interface ShipRef {
  fleetyardsId: string;
  name: string;
  slug: string;
}

interface ShipsIndex {
  byName: Map<string, ShipRef>;
  byNameLower: Map<string, ShipRef>;
  bySlug: Map<string, ShipRef>;
  byFleetyardsId: Map<string, ShipRef>;
}
```

**MANUAL_OVERRIDES constant:**
A `Record<string, string>` mapping codebase names to FleetYards slugs. Include ALL known discrepancies from research:
```typescript
export const MANUAL_OVERRIDES: Record<string, string> = {
  // Extra words in codebase name
  'Ares Star Fighter Inferno': 'ares-inferno',
  'Ares Star Fighter Ion': 'ares-ion',
  'C8R Pisces Rescue': 'c8r-pisces',

  // Missing suffix in codebase
  'Gladius Pirate': 'gladius-pirate-edition',

  // Punctuation differences
  'F7C M Super Hornet Mk II': 'f7c-m-super-hornet-mk-ii',

  // Misspelling in codebase
  'F8C Lightening': 'f8c-lightning',

  // "Best In Show" editions (map to base variant)
  'Hammerhead Best In Show Edition': 'hammerhead',
  'Reclaimer Best In Show Edition': 'reclaimer',
  'Cutlass Black Best In Show Edition': 'cutlass-black',
  'Caterpillar Best In Show Edition': 'caterpillar',
  'Caterpillar Pirate Edition': 'caterpillar',

  // Special editions
  'Constellation Phoenix Emerald': 'constellation-phoenix',

  // Heartseeker Mk II -> closest match
  'F7C-M Hornet Heartseeker Mk II': 'f7c-m-super-hornet-heartseeker',
};
```

**`nameToSlug(name: string): string` helper:**
Convert a ship name to FleetYards slug format: `name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/, '').replace(/^-+/, '')`. This must match the FleetYards slug convention exactly.

**`buildShipsIndex(): Promise<ShipsIndex>`:**
- Import `connectToDatabase` from `@/lib/mongodb` (NOT mongodb-client -- use the same pattern as mission-storage.ts and ship-storage.ts)
- Query `ships` collection with projection `{ _id: 0, fleetyardsId: 1, name: 1, slug: 1 }`
- Build four Maps: byName, byNameLower (lowercase key), bySlug, byFleetyardsId
- Return the ShipsIndex object

**`resolveShipName(name: string, index: ShipsIndex, overrides?: Record<string, string>): MatchResult | null`:**
Multi-pass matching in this exact order:
1. **Manual override** (highest priority): Check if `name` is in overrides map. The override VALUE is a slug, so look it up in `index.bySlug`. If found, return with strategy `'manual-override'`.
2. **Exact match**: Look up `name` in `index.byName`. Return with strategy `'exact'`.
3. **Case-insensitive**: Look up `name.toLowerCase()` in `index.byNameLower`. Return with strategy `'case-insensitive'`.
4. **Slug match**: Convert `name` to slug via `nameToSlug()`, look up in `index.bySlug`. Return with strategy `'slug'`.
5. **Contains match**: Iterate `index.byName` entries. If `ship.name.toLowerCase().includes(nameLower)` OR `nameLower.includes(ship.name.toLowerCase())`, return with strategy `'contains'`. Use the FIRST match found.
6. If no match found in any pass, return `null`.

Default `overrides` parameter to `MANUAL_OVERRIDES` if not provided.

**`UUID_REGEX` constant:**
Export `const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;` for use by migration script to check if a field is already a valid UUID.

**Important:**
- Do NOT use `connectToDatabase` from `mongodb-client.ts` -- use `mongodb.ts` which returns `{ client, db }` (same as mission-storage.ts pattern)
- Use `const DATABASE_ID = process.env.COSMOS_DATABASE_ID || 'aydocorp-database';` only if needed (connectToDatabase from mongodb.ts already handles database selection)
- Export all types and functions for use by the migration script
  </action>
  <verify>
Run `npm run type-check` -- zero errors.
Verify exports exist:
- `grep "export.*resolveShipName" src/lib/ship-name-matcher.ts` -- found
- `grep "export.*buildShipsIndex" src/lib/ship-name-matcher.ts` -- found
- `grep "export.*MANUAL_OVERRIDES" src/lib/ship-name-matcher.ts` -- found
- `grep "export.*UUID_REGEX" src/lib/ship-name-matcher.ts` -- found
- `grep "F8C Lightening" src/lib/ship-name-matcher.ts` -- found (misspelling override present)
- `grep "Ares Star Fighter" src/lib/ship-name-matcher.ts` -- found (extra words override present)
- Count override entries: should be >= 13 entries
  </verify>
  <done>
`ship-name-matcher.ts` exports `buildShipsIndex`, `resolveShipName`, `MANUAL_OVERRIDES`, `UUID_REGEX`, and all types. The override map contains all 13+ known discrepancies. The multi-pass matching follows the exact order: manual-override, exact, case-insensitive, slug, contains. Type-check passes.
  </done>
</task>

</tasks>

<verification>
- `npm run type-check` passes with zero errors
- `ship-name-matcher.ts` has no runtime dependencies beyond `mongodb` (already installed)
- All 13 known name discrepancies from research are present in `MANUAL_OVERRIDES`
- The matching order is: manual-override -> exact -> case-insensitive -> slug -> contains
- `buildShipsIndex` uses `connectToDatabase` from `@/lib/mongodb` (correct import path)
</verification>

<success_criteria>
- `src/lib/ship-name-matcher.ts` exists with all exports
- Type-check passes
- Override map covers all known discrepancies from research
- Multi-pass matching strategy implemented in correct priority order
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-migration/03-01-SUMMARY.md`
</output>
