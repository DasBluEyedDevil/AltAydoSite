---
phase: 01-sync-engine-and-data-model
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/lib/ship-sync.ts
  - src/app/api/cron/ship-sync/route.ts
  - src/instrumentation.ts
autonomous: true

must_haves:
  truths:
    - "Running the sync populates the ships collection with 500+ ship documents"
    - "If FleetYards API is unreachable, existing ship data is preserved unchanged"
    - "Malformed ship records are logged and skipped without blocking the rest of the sync"
    - "A sync audit log records every sync run with timestamp, ship count, errors, and duration"
    - "Sync can be triggered via HTTP GET to /api/cron/ship-sync with CRON_SECRET auth"
    - "Sync runs automatically on a cron schedule when the server starts"
    - "Sync aborts if fetched count drops below 80% of previous sync count"
  artifacts:
    - path: "src/lib/ship-sync.ts"
      provides: "Sync orchestrator with fetch-validate-transform-upsert pipeline and cron scheduling"
      exports: ["syncShipsFromFleetYards", "startShipSyncCron"]
      min_lines: 80
    - path: "src/app/api/cron/ship-sync/route.ts"
      provides: "HTTP endpoint for cron-triggered and manual sync"
      exports: ["GET", "POST"]
      min_lines: 30
    - path: "src/instrumentation.ts"
      provides: "Next.js instrumentation hook that starts cron on server boot"
      exports: ["register"]
      min_lines: 5
  key_links:
    - from: "src/lib/ship-sync.ts"
      to: "src/lib/fleetyards/client.ts"
      via: "imports fetchAllShips"
      pattern: "fetchAllShips"
    - from: "src/lib/ship-sync.ts"
      to: "src/lib/fleetyards/transform.ts"
      via: "imports transformFleetYardsShip"
      pattern: "transformFleetYardsShip"
    - from: "src/lib/ship-sync.ts"
      to: "src/lib/ship-storage.ts"
      via: "imports upsertShips, getShipCount, saveSyncStatus, getLatestSyncStatus"
      pattern: "upsertShips|saveSyncStatus|getLatestSyncStatus|getShipCount"
    - from: "src/lib/ship-sync.ts"
      to: "src/types/ship.ts"
      via: "imports FleetYardsShipSchema for Zod validation"
      pattern: "FleetYardsShipSchema"
    - from: "src/app/api/cron/ship-sync/route.ts"
      to: "src/lib/ship-sync.ts"
      via: "imports syncShipsFromFleetYards"
      pattern: "syncShipsFromFleetYards"
    - from: "src/instrumentation.ts"
      to: "src/lib/ship-sync.ts"
      via: "dynamic import of startShipSyncCron"
      pattern: "startShipSyncCron"
---

<objective>
Build the sync orchestrator that ties together the FleetYards API client, Zod validation, transform, and storage into a complete sync pipeline. Create the cron HTTP endpoint and the Next.js instrumentation hook for automatic scheduling.

Purpose: This is the capstone plan that wires everything together. After this plan, the ship sync pipeline is fully operational: ships flow from FleetYards API through validation and transformation into MongoDB, with an audit trail of every sync run and automatic cron scheduling.

Output: `src/lib/ship-sync.ts` (orchestrator), `src/app/api/cron/ship-sync/route.ts` (HTTP trigger), `src/instrumentation.ts` (cron boot).
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-sync-engine-and-data-model/01-RESEARCH.md
@.planning/phases/01-sync-engine-and-data-model/01-01-SUMMARY.md
@.planning/phases/01-sync-engine-and-data-model/01-02-SUMMARY.md
@.planning/phases/01-sync-engine-and-data-model/01-03-SUMMARY.md

# Modules from prior plans
@src/types/ship.ts
@src/lib/fleetyards/client.ts
@src/lib/fleetyards/transform.ts
@src/lib/ship-storage.ts

# Existing pattern to mirror
@src/app/api/cron/discord-sync/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync orchestrator with Zod validation pipeline and cron scheduling</name>
  <files>src/lib/ship-sync.ts</files>
  <action>
Create `src/lib/ship-sync.ts` with two exported functions: `syncShipsFromFleetYards()` (the sync pipeline) and `startShipSyncCron()` (the cron scheduler).

**`syncShipsFromFleetYards()` function:**

Signature:
```typescript
export async function syncShipsFromFleetYards(): Promise<SyncStatusDocument>
```

Pipeline steps (in order):

1. **Start timer:** `const startTime = Date.now()`

2. **Get previous sync status:** Call `getLatestSyncStatus()`. Store `previousShipCount` for sanity checking.

3. **Determine next syncVersion:** If previous status exists, `previousStatus.syncVersion + 1`, otherwise `1`.

4. **Fetch all ships from FleetYards:** Call `fetchAllShips()`. Destructure `{ ships: rawShips, pagesProcessed, errors: fetchErrors }`.

5. **Handle empty fetch:** If `rawShips.length === 0`:
   - Log `console.error('[ship-sync] Fetch returned 0 ships -- aborting sync to preserve existing data')`
   - Save a sync status with `status: 'failed'`, `errors: ['Fetch returned 0 ships']`
   - Return the failed status
   - This satisfies SYNC-05: never wipe existing data

6. **Sanity check count drop:** If `previousShipCount > 0` and `rawShips.length < previousShipCount * 0.8`:
   - Log `console.warn('[ship-sync] Fetched ${rawShips.length} ships but expected ~${previousShipCount} -- aborting sync')`
   - Save sync status with `status: 'failed'`, `errors: ['Ship count dropped below 80% threshold']`
   - Return failed status

7. **Validate and transform each ship:**
   ```typescript
   const validated: ReturnType<typeof transformFleetYardsShip>[] = [];
   const validationErrors: string[] = [];

   for (const raw of rawShips) {
     const result = FleetYardsShipSchema.safeParse(raw);
     if (result.success) {
       validated.push(transformFleetYardsShip(result.data, syncVersion));
     } else {
       const shipName = (raw as any)?.name || 'unknown';
       const errorMsg = `Validation failed for "${shipName}": ${result.error.issues.map(i => i.message).join(', ')}`;
       validationErrors.push(errorMsg);
       console.warn(`[ship-sync] ${errorMsg}`);
     }
   }
   ```

8. **Upsert validated ships:** If `validated.length > 0`, call `upsertShips(validated)`. Get `{ newShips, updatedShips, unchangedShips }`.

9. **Get final ship count:** Call `getShipCount()`.

10. **Calculate duration:** `Date.now() - startTime`

11. **Determine status:** `'failed'` if validated.length === 0, `'partial'` if validationErrors.length > 0, `'success'` otherwise.

12. **Build and save sync status:**
    ```typescript
    const syncStatus: Omit<SyncStatusDocument, '_id'> = {
      type: 'ship-sync',
      syncVersion,
      lastSyncAt: new Date(),
      shipCount: finalShipCount,
      newShips: upsertResult?.newShips ?? 0,
      updatedShips: upsertResult?.updatedShips ?? 0,
      unchangedShips: upsertResult?.unchangedShips ?? 0,
      skippedShips: validationErrors.length,
      durationMs: duration,
      status,
      errors: [...fetchErrors, ...validationErrors],
      pagesProcessed,
    };
    await saveSyncStatus(syncStatus);
    ```

13. **Log summary:** `console.log('[ship-sync] Sync complete:', JSON.stringify({ status, shipCount, newShips, updatedShips, skippedShips, durationMs }))`

14. **Return:** Cast as `SyncStatusDocument` and return.

**`startShipSyncCron()` function:**

```typescript
export function startShipSyncCron(): void {
  const schedule = process.env.SHIP_SYNC_CRON_SCHEDULE || '0 */6 * * *';
  const enabled = process.env.SHIP_SYNC_ENABLED !== 'false';

  if (!enabled) {
    console.log('[ship-sync] Cron disabled via SHIP_SYNC_ENABLED=false');
    return;
  }

  const cron = require('node-cron');

  if (!cron.validate(schedule)) {
    console.error(`[ship-sync] Invalid cron schedule: ${schedule}`);
    return;
  }

  cron.schedule(schedule, async () => {
    console.log('[ship-sync] Cron triggered sync');
    try {
      await syncShipsFromFleetYards();
    } catch (error) {
      console.error('[ship-sync] Cron sync failed:', error);
    }
  });

  console.log(`[ship-sync] Cron scheduled: ${schedule}`);

  // Check if sync is overdue (>24h since last) and run immediately
  checkAndRunOverdueSync().catch(err => {
    console.warn('[ship-sync] Overdue sync check failed:', err);
  });
}
```

**`checkAndRunOverdueSync()` helper (not exported):**
```typescript
async function checkAndRunOverdueSync(): Promise<void> {
  const lastSync = await getLatestSyncStatus();
  const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

  if (!lastSync || lastSync.lastSyncAt < twentyFourHoursAgo) {
    console.log('[ship-sync] Sync is overdue, running now...');
    await syncShipsFromFleetYards();
  }
}
```

**Imports:**
- `fetchAllShips` from `@/lib/fleetyards/client`
- `transformFleetYardsShip` from `@/lib/fleetyards/transform`
- `upsertShips`, `getShipCount`, `saveSyncStatus`, `getLatestSyncStatus` from `@/lib/ship-storage`
- `FleetYardsShipSchema`, `SyncStatusDocument` from `@/types/ship`

Use `require('node-cron')` (not import) in `startShipSyncCron` because node-cron should only be loaded server-side and this avoids potential ESM/CJS issues with Next.js.
  </action>
  <verify>
Run `npm run type-check` -- no type errors.
Verify exports: syncShipsFromFleetYards, startShipSyncCron.
Verify the sync function handles: empty fetch (abort), count drop below 80% (abort), Zod validation per record, upsert, audit log save.
  </verify>
  <done>syncShipsFromFleetYards() implements the full pipeline: fetch -> sanity check -> validate per record -> transform -> upsert -> audit log. startShipSyncCron() schedules sync via node-cron with overdue-sync-on-startup recovery.</done>
</task>

<task type="auto">
  <name>Task 2: Create cron HTTP endpoint and instrumentation hook</name>
  <files>src/app/api/cron/ship-sync/route.ts, src/instrumentation.ts</files>
  <action>
**File 1: `src/app/api/cron/ship-sync/route.ts`**

Mirror the existing `src/app/api/cron/discord-sync/route.ts` pattern exactly. This route serves two purposes: (1) external cron service can call it on a schedule, (2) manual trigger for testing.

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { syncShipsFromFleetYards } from '@/lib/ship-sync';

export const runtime = 'nodejs';

export async function GET(request: NextRequest) {
  try {
    console.log('[ship-sync] API sync triggered');

    // Auth check using existing CRON_SECRET pattern
    const cronSecret = process.env.CRON_SECRET;
    if (cronSecret) {
      const authHeader = request.headers.get('authorization');
      if (authHeader !== `Bearer ${cronSecret}`) {
        console.log('[ship-sync] Unauthorized cron request');
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
    }

    const result = await syncShipsFromFleetYards();

    console.log('[ship-sync] API sync completed:', {
      status: result.status,
      shipCount: result.shipCount,
      newShips: result.newShips,
      updatedShips: result.updatedShips,
      skippedShips: result.skippedShips,
    });

    if (result.errors.length > 0) {
      console.warn('[ship-sync] Sync completed with errors:', result.errors.slice(0, 10));
    }

    return NextResponse.json({
      success: result.status !== 'failed',
      result: {
        status: result.status,
        shipCount: result.shipCount,
        newShips: result.newShips,
        updatedShips: result.updatedShips,
        unchangedShips: result.unchangedShips,
        skippedShips: result.skippedShips,
        durationMs: result.durationMs,
        pagesProcessed: result.pagesProcessed,
        errorCount: result.errors.length,
        hasErrors: result.errors.length > 0,
      },
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('[ship-sync] API sync failed:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString(),
    }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  return GET(request);
}
```

**File 2: `src/instrumentation.ts`**

Create this file in `src/` root (NOT in `src/app/`). This is the Next.js instrumentation hook that runs once on server startup. No `experimental` flag needed in Next.js 15.

```typescript
export async function register() {
  // Only run cron scheduler on the Node.js server runtime
  // (not during build, not in Edge runtime)
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    const { startShipSyncCron } = await import('./lib/ship-sync');
    startShipSyncCron();
  }
}
```

This file MUST use dynamic import (`await import()`) because:
1. The import only runs on Node.js runtime (not Edge)
2. Dynamic import defers loading until the function is called
3. This prevents node-cron from being bundled into Edge runtime

Do NOT add any other initialization to this file for now. Keep it minimal and focused on ship sync cron.
  </action>
  <verify>
Run `npm run type-check` -- no type errors.
Run `npm run build` -- build succeeds (instrumentation.ts is picked up by Next.js 15 automatically).
Verify `src/app/api/cron/ship-sync/route.ts` exports GET and POST.
Verify `src/instrumentation.ts` exports register.
Verify the cron route mirrors the discord-sync route pattern (CRON_SECRET auth, try/catch, JSON response).
  </verify>
  <done>The cron HTTP endpoint at /api/cron/ship-sync accepts GET/POST with CRON_SECRET Bearer auth, runs the full sync pipeline, and returns detailed results. The instrumentation hook starts the node-cron scheduler on server boot with dynamic import to avoid Edge runtime issues.</done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes with no errors
2. `npm run build` completes successfully
3. All 13 requirements covered:
   - SYNC-01: fetchAllShips() in client.ts fetches all ships via paginated GET requests
   - SYNC-02: transformFleetYardsShip() maps API response to internal schema
   - SYNC-03: upsertShips() upserts to ships collection keyed on FleetYards UUID
   - SYNC-04: startShipSyncCron() + instrumentation.ts triggers sync on schedule
   - SYNC-05: Empty fetch and count-drop-below-80% both abort without modifying existing data
   - SYNC-06: FleetYardsShipSchema.safeParse() validates each record, skips failures
   - SYNC-07: saveSyncStatus() records every sync run with all required fields
   - DATA-01: fleetyardsId is the canonical identifier with unique index
   - DATA-02: ShipDocument includes all required spec fields
   - DATA-03: images object stores multiple view URLs in multiple resolutions
   - DATA-04: description and storeUrl stored in ShipDocument
   - DATA-05: Indexes on fleetyardsId (unique), slug (unique), manufacturer.code, productionStatus, name search via regex (no text index)
   - DATA-06: syncedAt and syncVersion tracked per ship
4. ship-sync.ts orchestrates the full pipeline: fetch -> sanity check -> validate -> transform -> upsert -> audit
5. Cron route mirrors discord-sync pattern exactly
6. instrumentation.ts uses dynamic import for Node.js-only code
</verification>

<success_criteria>
- The complete sync pipeline compiles and builds without errors
- sync function handles all error cases: empty fetch, count drop, validation failures, upsert errors
- Cron route is accessible at /api/cron/ship-sync with CRON_SECRET auth
- Cron scheduler starts automatically on server boot via instrumentation hook
- Overdue sync detection runs sync immediately if >24h since last successful sync
- No existing files are broken -- only new files created (except mongo-indexes.ts which was extended in Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/01-sync-engine-and-data-model/01-04-SUMMARY.md`
</output>
