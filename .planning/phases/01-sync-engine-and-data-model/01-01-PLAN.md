---
phase: 01-sync-engine-and-data-model
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/types/ship.ts
  - src/lib/fleetyards/types.ts
  - .env.example
autonomous: true

must_haves:
  truths:
    - "node-cron and @types/node-cron are installed and importable"
    - "ShipDocument type describes all fields stored in MongoDB ships collection"
    - "SyncStatusDocument type describes sync audit log records"
    - "FleetYardsShipResponse type matches the actual FleetYards API response shape"
    - "Zod schemas validate FleetYards API response fields at runtime"
    - "Environment variables for ship sync are documented in .env.example"
  artifacts:
    - path: "src/types/ship.ts"
      provides: "ShipDocument interface, SyncStatusDocument interface, Zod schemas"
      exports: ["ShipDocument", "SyncStatusDocument", "FleetYardsShipSchema", "ShipDocumentSchema"]
    - path: "src/lib/fleetyards/types.ts"
      provides: "FleetYards API response TypeScript types"
      exports: ["FleetYardsShipResponse", "FleetYardsImageView", "FleetYardsManufacturer"]
    - path: "package.json"
      provides: "node-cron dependency"
      contains: "node-cron"
  key_links:
    - from: "src/types/ship.ts"
      to: "src/lib/fleetyards/types.ts"
      via: "Zod schema validates FleetYardsShipResponse shape"
      pattern: "FleetYardsShipSchema"
---

<objective>
Install the node-cron dependency, define all TypeScript types and Zod validation schemas for the ship sync pipeline, and document new environment variables.

Purpose: Every downstream module (API client, transform, storage, sync orchestrator) depends on these type definitions. Getting the data shapes right first prevents rework. Zod schemas are the trust boundary between the external FleetYards API and our database.

Output: `src/types/ship.ts` with ShipDocument + SyncStatusDocument + Zod schemas, `src/lib/fleetyards/types.ts` with FleetYards API response types, node-cron installed, .env.example updated.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-sync-engine-and-data-model/01-RESEARCH.md

# Key existing files to understand patterns
@src/types/ShipData.ts
@src/lib/mongodb-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install node-cron dependency and update .env.example</name>
  <files>package.json, .env.example</files>
  <action>
Run `npm install node-cron@^4.2.1` and `npm install -D @types/node-cron@^3.0.11` to add the cron scheduling dependency.

Then append the following to `.env.example` after the existing content:

```
# Ship sync configuration
SHIP_SYNC_CRON_SCHEDULE=0 */6 * * *
SHIP_SYNC_ENABLED=true
# CRON_SECRET is reused for ship-sync endpoint auth (already exists if Discord sync is configured)
```

Do NOT modify any existing lines in .env.example. Only append new lines.
  </action>
  <verify>
Run `node -e "require('node-cron')"` -- should exit 0 with no errors.
Run `grep "SHIP_SYNC" .env.example` -- should show both new env vars.
Check package.json contains `"node-cron"` in dependencies and `"@types/node-cron"` in devDependencies.
  </verify>
  <done>node-cron is importable at runtime, @types/node-cron provides TypeScript types, and .env.example documents SHIP_SYNC_CRON_SCHEDULE and SHIP_SYNC_ENABLED.</done>
</task>

<task type="auto">
  <name>Task 2: Create FleetYards API response types</name>
  <files>src/lib/fleetyards/types.ts</files>
  <action>
Create directory `src/lib/fleetyards/` and file `types.ts` containing TypeScript interfaces that mirror the actual FleetYards API response shape. These are raw API types -- NOT our internal storage types.

Define these interfaces:

1. `FleetYardsImageView` -- the image view object with `source`, `small`, `medium`, `large` string fields.

2. `FleetYardsManufacturer` -- with `name: string`, `longName: string`, `slug: string`, `code: string`.

3. `FleetYardsShipResponse` -- the full ship object from `/v1/models`. Include ALL of these fields (verified from live API):
   - `id: string` (UUID)
   - `name: string`
   - `slug: string`
   - `scIdentifier: string | null`
   - `rsiId: number | null`
   - `rsiName: string | null`
   - `rsiSlug: string | null`
   - `manufacturer: FleetYardsManufacturer`
   - `classification: string`
   - `classificationLabel: string`
   - `focus: string`
   - `productionStatus: string`
   - `size: string`
   - `crew: { min: number; max: number; minLabel: string; maxLabel: string }`
   - `cargo: number`
   - `mass: number`
   - `length: number`
   - `beam: number`
   - `height: number`
   - `hydrogenFuelTankSize: number | null`
   - `quantumFuelTankSize: number | null`
   - `scmSpeed: number | null`
   - `pledgePrice: number | null`
   - `price: number | null`
   - `description: string | null`
   - `storeImage: string | null`
   - `storeUrl: string | null`
   - `angledView: FleetYardsImageView | null`
   - `sideView: FleetYardsImageView | null`
   - `topView: FleetYardsImageView | null`
   - `frontView: FleetYardsImageView | null`
   - `fleetchartImage: string | null`
   - `onSale: boolean`
   - `hasImages: boolean`
   - `hasPaints: boolean`
   - `lastUpdatedAt: string`
   - `createdAt: string`
   - `updatedAt: string`

Export all three interfaces. Add a JSDoc comment at the top explaining these types mirror the FleetYards v1 API response and should NOT be used as internal storage types.
  </action>
  <verify>
Run `npx tsc --noEmit src/lib/fleetyards/types.ts` or `npm run type-check` -- no type errors from this file.
  </verify>
  <done>FleetYardsShipResponse, FleetYardsImageView, and FleetYardsManufacturer interfaces are exported and match the verified FleetYards API response shape.</done>
</task>

<task type="auto">
  <name>Task 3: Create ShipDocument types and Zod validation schemas</name>
  <files>src/types/ship.ts</files>
  <action>
Create `src/types/ship.ts` with our internal data types and Zod validation schemas.

**ShipDocument interface** (the MongoDB document shape):
- `_id?: ObjectId` (import from 'mongodb')
- `fleetyardsId: string` -- FleetYards UUID, canonical identifier
- `slug: string` -- URL-friendly identifier
- `name: string` -- display name
- `scIdentifier: string | null` -- in-game identifier
- `manufacturer: { name: string; code: string; slug: string }` -- simplified from API (drop longName)
- `classification: string`
- `classificationLabel: string`
- `focus: string`
- `size: string`
- `productionStatus: string`
- `crew: { min: number; max: number }`
- `cargo: number` (SCU)
- `length: number`, `beam: number`, `height: number` (meters)
- `mass: number` (kg)
- `scmSpeed: number | null`
- `hydrogenFuelTankSize: number | null`
- `quantumFuelTankSize: number | null`
- `pledgePrice: number | null` (USD)
- `price: number | null` (aUEC)
- `description: string | null`
- `storeUrl: string | null`
- `images: { store: string | null; angledView: string | null; angledViewMedium: string | null; sideView: string | null; sideViewMedium: string | null; topView: string | null; topViewMedium: string | null; frontView: string | null; frontViewMedium: string | null; fleetchartImage: string | null }`
- `syncedAt: Date`
- `syncVersion: number`
- `fleetyardsUpdatedAt: string`
- `createdAt: Date`
- `updatedAt: Date`

**SyncStatusDocument interface**:
- `_id?: ObjectId`
- `type: 'ship-sync'`
- `syncVersion: number`
- `lastSyncAt: Date`
- `shipCount: number`
- `newShips: number`
- `updatedShips: number`
- `unchangedShips: number`
- `skippedShips: number`
- `durationMs: number`
- `status: 'success' | 'partial' | 'failed'`
- `errors: string[]`
- `pagesProcessed: number`

**FleetYardsShipSchema** (Zod schema for validating raw API response before transform):
Use `import { z } from 'zod'`. This schema validates the MINIMUM required fields from the FleetYards API. Use `.passthrough()` so unknown fields don't cause failures.

Required fields (must exist and have correct type):
- `id: z.string().uuid()`
- `name: z.string().min(1)`
- `slug: z.string().min(1)`
- `manufacturer: z.object({ name: z.string(), code: z.string(), slug: z.string() }).passthrough()`

Optional/nullable fields (use `.nullable()` or `.optional()` as appropriate):
- All other fields should be typed but nullable/optional so Zod doesn't reject ships missing non-critical data

Export: `FleetYardsShipSchema` (the Zod schema object), and infer type `ValidatedFleetYardsShip = z.infer<typeof FleetYardsShipSchema>`.

Important: Do NOT import from `./fleetyards/types.ts` in this file. The Zod schema serves as the validation layer and produces its own inferred type. The TypeScript interfaces in fleetyards/types.ts are for documentation and type-checking API client code, while Zod schemas are for runtime validation at the trust boundary.
  </action>
  <verify>
Run `npm run type-check` -- no type errors.
Verify the file exports ShipDocument, SyncStatusDocument, FleetYardsShipSchema, and ValidatedFleetYardsShip by checking the export statements.
  </verify>
  <done>ShipDocument and SyncStatusDocument interfaces define our internal MongoDB document shapes. FleetYardsShipSchema Zod schema validates minimum required fields from the API with passthrough for unknown fields. ValidatedFleetYardsShip provides the inferred type from Zod validation.</done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes with no errors from new files
2. `node -e "require('node-cron')"` exits cleanly
3. `src/types/ship.ts` exports ShipDocument, SyncStatusDocument, FleetYardsShipSchema, ValidatedFleetYardsShip
4. `src/lib/fleetyards/types.ts` exports FleetYardsShipResponse, FleetYardsImageView, FleetYardsManufacturer
5. `.env.example` contains SHIP_SYNC_CRON_SCHEDULE and SHIP_SYNC_ENABLED
6. No existing files are broken (only .env.example is appended to, everything else is new)
</verification>

<success_criteria>
- All type definitions compile without errors
- node-cron is installed and importable
- Zod schema can validate a sample FleetYards ship object (has id, name, slug, manufacturer)
- .env.example documents the new environment variables
- No changes to existing source files (only new files + .env.example append + package.json)
</success_criteria>

<output>
After completion, create `.planning/phases/01-sync-engine-and-data-model/01-01-SUMMARY.md`
</output>
