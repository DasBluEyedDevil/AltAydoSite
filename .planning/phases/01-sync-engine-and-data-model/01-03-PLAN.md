---
phase: 01-sync-engine-and-data-model
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/ship-storage.ts
  - src/lib/mongo-indexes.ts
autonomous: true

must_haves:
  truths:
    - "Ships are upserted to MongoDB ships collection keyed on FleetYards UUID"
    - "Upsert never deletes existing ships -- only inserts new or updates existing"
    - "createdAt is only set on first insert, never overwritten on update"
    - "MongoDB indexes enforce unique constraint on fleetyardsId and slug"
    - "Sync audit log can be saved and retrieved from sync-status collection"
    - "Ship count can be queried for sanity checking before/after sync"
  artifacts:
    - path: "src/lib/ship-storage.ts"
      provides: "MongoDB CRUD for ships and sync-status collections"
      exports: ["upsertShips", "getShipCount", "getLatestSyncStatus", "saveSyncStatus", "getShipByFleetyardsId", "getShipBySlug"]
      min_lines: 80
    - path: "src/lib/mongo-indexes.ts"
      provides: "Ships and sync-status collection indexes"
      contains: "ships"
  key_links:
    - from: "src/lib/ship-storage.ts"
      to: "src/lib/mongodb-client.ts"
      via: "imports connectToDatabase for MongoDB client access"
      pattern: "connectToDatabase|mongodb-client"
    - from: "src/lib/ship-storage.ts"
      to: "src/types/ship.ts"
      via: "imports ShipDocument and SyncStatusDocument types"
      pattern: "ShipDocument|SyncStatusDocument"
    - from: "src/lib/mongo-indexes.ts"
      to: "MongoDB ships collection"
      via: "createIndex calls for fleetyardsId, slug, manufacturer.code, etc."
      pattern: "ships.*createIndex"
---

<objective>
Create the ship storage module for MongoDB CRUD operations on the ships and sync-status collections, and extend the existing MongoDB index setup to include ship-related indexes.

Purpose: The storage module is the data persistence layer for the sync pipeline. It handles bulk upserts (the core sync operation), sync audit logging, and ship lookups that downstream API routes will need. The indexes ensure query performance and data integrity (unique fleetyardsId, unique slug).

Output: `src/lib/ship-storage.ts` (new) and `src/lib/mongo-indexes.ts` (extended).
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-sync-engine-and-data-model/01-RESEARCH.md
@.planning/phases/01-sync-engine-and-data-model/01-01-SUMMARY.md

# Types created in Plan 01
@src/types/ship.ts

# Existing patterns to follow
@src/lib/mongodb-client.ts
@src/lib/mongo-indexes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ship-storage.ts with upsert and query functions</name>
  <files>src/lib/ship-storage.ts</files>
  <action>
Create `src/lib/ship-storage.ts` following the project's storage module pattern from `mongodb-client.ts`. Unlike `user-storage.ts`, ship-storage does NOT need local JSON fallback -- ships are cached reference data from an external API, so if MongoDB is down, ships are simply unavailable.

**Database access pattern:**
Import `connectToDatabase` from `@/lib/mongodb-client`. Use it to get the MongoDB client, then access the database and collections directly:
```typescript
const { client } = await connectToDatabase();
const db = client.db(process.env.COSMOS_DATABASE_ID || 'aydocorp-database');
const shipsCollection = db.collection('ships');
const syncStatusCollection = db.collection('sync-status');
```

**Functions to implement:**

1. `upsertShips(ships: Omit<ShipDocument, '_id' | 'createdAt'>[]): Promise<{ newShips: number; updatedShips: number; unchangedShips: number }>`
   - Uses `bulkWrite` with `ordered: false` for maximum throughput
   - Each ship becomes an `updateOne` operation:
     ```typescript
     {
       updateOne: {
         filter: { fleetyardsId: ship.fleetyardsId },
         update: {
           $set: { ...ship },
           $setOnInsert: { createdAt: new Date() },
         },
         upsert: true,
       },
     }
     ```
   - Returns counts from `bulkWriteResult`: `upsertedCount` (new), `modifiedCount` (updated), `matchedCount - modifiedCount` (unchanged)
   - If bulkWrite fails (Cosmos DB compatibility issue), fall back to individual upserts with per-document error handling. Log the bulkWrite error and proceed with individual `updateOne` calls.
   - Log: `console.log('[ship-storage] Upserting ${ships.length} ships...')`

2. `getShipCount(): Promise<number>`
   - Returns `shipsCollection.countDocuments({})`
   - Used for pre-sync sanity checks

3. `getShipByFleetyardsId(fleetyardsId: string): Promise<ShipDocument | null>`
   - `findOne({ fleetyardsId })` with `{ projection: { _id: 0 } }`

4. `getShipBySlug(slug: string): Promise<ShipDocument | null>`
   - `findOne({ slug })` with `{ projection: { _id: 0 } }`

5. `saveSyncStatus(status: Omit<SyncStatusDocument, '_id'>): Promise<void>`
   - `insertOne(status)` into sync-status collection
   - This creates a new audit record each sync (append-only log, never update)

6. `getLatestSyncStatus(): Promise<SyncStatusDocument | null>`
   - `findOne({ type: 'ship-sync' }, { sort: { lastSyncAt: -1 }, projection: { _id: 0 } })`
   - Returns the most recent sync audit record

**Error handling:**
Every function wraps database calls in try/catch. On error:
- Log with `console.error('[ship-storage] Error in ${functionName}:', error)`
- Re-throw for upsertShips (caller needs to know)
- Return null/0 for read functions (graceful degradation)

**Important anti-patterns to avoid:**
- Do NOT add local JSON fallback (unlike user-storage.ts)
- Do NOT use `deleteMany` anywhere -- upsert-never-delete pattern
- Do NOT add Mongoose or Prisma -- use raw MongoDB driver like the rest of the codebase
- Do NOT call `ensureConnection()` from mongodb-client.ts -- use `connectToDatabase()` which handles that internally
  </action>
  <verify>
Run `npm run type-check` -- no type errors.
Verify the file exports: upsertShips, getShipCount, getShipByFleetyardsId, getShipBySlug, saveSyncStatus, getLatestSyncStatus.
Verify no imports from local-storage or JSON file modules.
  </verify>
  <done>ship-storage.ts provides bulk upsert (with individual fallback), ship queries by UUID and slug, sync status append-only audit log, and ship count. All using MongoDB driver directly with no local fallback.</done>
</task>

<task type="auto">
  <name>Task 2: Extend mongo-indexes.ts with ships and sync-status indexes</name>
  <files>src/lib/mongo-indexes.ts</files>
  <action>
Read the existing `src/lib/mongo-indexes.ts` and add two new index blocks at the end of the `ensureMongoIndexes` function, following the exact same pattern as existing blocks (try/catch wrapper, `.catch(() => {})` on each createIndex, Promise.all).

**Add ships collection indexes:**
```typescript
try {
  const ships = db.collection('ships');
  await Promise.all([
    // Primary lookup by FleetYards UUID (unique)
    ships.createIndex({ fleetyardsId: 1 }, { unique: true }).catch(() => {}),
    // Slug lookup for URL-based routes (unique)
    ships.createIndex({ slug: 1 }, { unique: true }).catch(() => {}),
    // Manufacturer filter queries
    ships.createIndex({ 'manufacturer.code': 1 }).catch(() => {}),
    // Production status filter
    ships.createIndex({ productionStatus: 1 }).catch(() => {}),
    // Sync housekeeping (find stale records)
    ships.createIndex({ syncVersion: 1 }).catch(() => {}),
    // Combined filter: manufacturer + size (common filter combo)
    ships.createIndex({ 'manufacturer.code': 1, size: 1 }).catch(() => {}),
  ]);
} catch (err) {
  console.warn('Index setup (ships) skipped or failed:', err);
}
```

**Add sync-status collection indexes:**
```typescript
try {
  const syncStatus = db.collection('sync-status');
  await Promise.all([
    // Find latest sync by type
    syncStatus.createIndex({ type: 1, lastSyncAt: -1 }).catch(() => {}),
  ]);
} catch (err) {
  console.warn('Index setup (sync-status) skipped or failed:', err);
}
```

**Do NOT:**
- Create text indexes (`{ name: 'text' }`) -- Cosmos DB may not support them. This is documented in RESEARCH.md as a pitfall.
- Modify any existing index blocks -- only append new ones
- Change the function signature or imports
  </action>
  <verify>
Run `npm run type-check` -- no type errors.
Verify `mongo-indexes.ts` contains `db.collection('ships')` and `db.collection('sync-status')`.
Verify no text indexes are created (no `'text'` string in index definitions).
Count the total try/catch blocks -- should be the original count plus 2.
  </verify>
  <done>mongo-indexes.ts creates unique indexes on ships.fleetyardsId and ships.slug, plus field indexes on manufacturer.code, productionStatus, syncVersion, and a compound index on manufacturer.code+size. sync-status collection gets a compound index on type+lastSyncAt. No text indexes created (Cosmos DB safety).</done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes with no errors
2. ship-storage.ts exports all 6 functions: upsertShips, getShipCount, getShipByFleetyardsId, getShipBySlug, saveSyncStatus, getLatestSyncStatus
3. mongo-indexes.ts contains ships and sync-status index blocks
4. No text indexes created anywhere
5. No local JSON fallback code in ship-storage.ts
6. upsertShips uses bulkWrite with ordered:false and $setOnInsert for createdAt
</verification>

<success_criteria>
- Ship upsert handles both bulkWrite and individual fallback paths
- Unique indexes on fleetyardsId and slug prevent duplicate ships
- Sync audit log is append-only (insertOne, never updateOne)
- All functions follow existing codebase patterns (try/catch, console.error logging)
- No existing indexes or code modified -- only additions
</success_criteria>

<output>
After completion, create `.planning/phases/01-sync-engine-and-data-model/01-03-SUMMARY.md`
</output>
