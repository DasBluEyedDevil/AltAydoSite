---
phase: 01-sync-engine-and-data-model
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/fleetyards/client.ts
  - src/lib/fleetyards/transform.ts
autonomous: true

must_haves:
  truths:
    - "FleetYards API client fetches all ships via paginated GET requests following Link header pagination"
    - "Client handles API unavailability gracefully with retry and returns partial results rather than crashing"
    - "Transform function maps every FleetYards response field to the correct ShipDocument field"
    - "Transform extracts multiple image URLs (store, angled, side, top, front) in source and medium resolutions"
    - "Transform preserves FleetYards UUID as fleetyardsId"
  artifacts:
    - path: "src/lib/fleetyards/client.ts"
      provides: "Paginated FleetYards API fetch with retry and delay"
      exports: ["fetchAllShips"]
      min_lines: 60
    - path: "src/lib/fleetyards/transform.ts"
      provides: "FleetYards response to ShipDocument mapper"
      exports: ["transformFleetYardsShip"]
      min_lines: 40
  key_links:
    - from: "src/lib/fleetyards/client.ts"
      to: "https://api.fleetyards.net/v1/models"
      via: "native fetch with pagination"
      pattern: "api\\.fleetyards\\.net/v1/models"
    - from: "src/lib/fleetyards/client.ts"
      to: "src/lib/fleetyards/types.ts"
      via: "imports FleetYardsShipResponse for type annotation"
      pattern: "FleetYardsShipResponse"
    - from: "src/lib/fleetyards/transform.ts"
      to: "src/types/ship.ts"
      via: "imports ShipDocument as return type"
      pattern: "ShipDocument"
    - from: "src/lib/fleetyards/transform.ts"
      to: "src/lib/fleetyards/types.ts"
      via: "imports FleetYardsShipResponse or ValidatedFleetYardsShip as input type"
      pattern: "FleetYardsShipResponse|ValidatedFleetYardsShip"
---

<objective>
Build the FleetYards API client that fetches all ships via paginated requests, and the transform function that maps API responses into our internal ShipDocument shape.

Purpose: These two modules form the data ingestion half of the sync pipeline. The client handles the unreliable external API (pagination, retry, rate limiting), and the transform provides a clean boundary between external data shape and internal storage shape.

Output: `src/lib/fleetyards/client.ts` (paginated fetch) and `src/lib/fleetyards/transform.ts` (field mapper).
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-sync-engine-and-data-model/01-RESEARCH.md
@.planning/phases/01-sync-engine-and-data-model/01-01-SUMMARY.md

# Types created in Plan 01
@src/types/ship.ts
@src/lib/fleetyards/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FleetYards API client with paginated fetch</name>
  <files>src/lib/fleetyards/client.ts</files>
  <action>
Create `src/lib/fleetyards/client.ts` with a `fetchAllShips()` function that fetches all ships from the FleetYards API.

**Constants:**
- `FLEETYARDS_API_BASE = 'https://api.fleetyards.net/v1'`
- `PER_PAGE = 200` (max allowed by API)
- `PAGE_DELAY_MS = 300` (delay between page fetches to respect undocumented rate limits)
- `MAX_RETRIES = 3` (retry count per page fetch)
- `MAX_PAGES = 10` (safety limit -- API has ~2-3 pages, this prevents infinite loops)

**`fetchAllShips()` function signature:**
```typescript
export async function fetchAllShips(): Promise<{ ships: FleetYardsShipResponse[]; pagesProcessed: number; errors: string[] }>
```

**Implementation details:**

1. Start at page 1, fetch `${FLEETYARDS_API_BASE}/models?page=${page}&perPage=${PER_PAGE}`
2. Use native `fetch()` (not Axios). Set headers: `Accept: application/json`.
3. On success (200): parse JSON response as `FleetYardsShipResponse[]`. If array is empty, stop pagination.
4. On 429 (rate limited): check for `Retry-After` header, wait that many seconds (or 5 seconds default), then retry. Count as a retry attempt.
5. On other non-200: log error with status code and response text, add to errors array, stop pagination for this page.
6. After each successful page fetch, add a `PAGE_DELAY_MS` delay before next page: `await new Promise(r => setTimeout(r, PAGE_DELAY_MS))`
7. Parse `Link` header to check for `rel="next"`. If no next link and response array is non-empty, check if response length < PER_PAGE to determine if this is the last page. Stop if either condition met.
8. Continue until no more pages or MAX_PAGES reached.

**Retry logic (per page):**
Create a helper `fetchWithRetry(url: string, retries: number)` that:
- Attempts the fetch
- On network error or 5xx status: waits `1000 * (attempt)` ms then retries
- On 429: waits `Retry-After` header value or 5 seconds
- After MAX_RETRIES: logs error, returns null (skip this page)
- On 4xx (not 429): does NOT retry, logs error, returns null

**Link header parsing:**
Create a helper `parseLinkHeader(linkHeader: string | null): { next?: string }` that:
- Parses RFC 8288 Link headers like `<https://api.fleetyards.net/v1/models?page=2&perPage=200>; rel="next"`
- Returns the URL for `rel="next"` if present, undefined otherwise

**Logging:**
- `console.log('[ship-sync] Fetching page ${page}...')` before each fetch
- `console.log('[ship-sync] Page ${page}: ${ships.length} ships')` after each successful fetch
- `console.warn('[ship-sync] Page ${page} failed: ${error}')` on failures
- `console.log('[ship-sync] Fetch complete: ${totalShips} ships from ${pagesProcessed} pages')` at end

Do NOT use Axios (unnecessary for simple GET requests). Do NOT use p-limit (just use inline delay). Do NOT add authentication (FleetYards API is public).
  </action>
  <verify>
Run `npm run type-check` -- no type errors.
Verify the file exports `fetchAllShips`.
Verify the file imports `FleetYardsShipResponse` from `./types`.
  </verify>
  <done>fetchAllShips() is exported and handles: pagination via Link headers, 300ms delay between pages, retry with backoff on 5xx/network errors, 429 handling with Retry-After, MAX_PAGES safety limit, and returns { ships, pagesProcessed, errors }.</done>
</task>

<task type="auto">
  <name>Task 2: Create FleetYards-to-ShipDocument transform function</name>
  <files>src/lib/fleetyards/transform.ts</files>
  <action>
Create `src/lib/fleetyards/transform.ts` with a function that maps a validated FleetYards API response object into our internal `ShipDocument` shape.

**Function signature:**
```typescript
export function transformFleetYardsShip(raw: ValidatedFleetYardsShip, syncVersion: number): Omit<ShipDocument, '_id' | 'createdAt'>
```

Import `ValidatedFleetYardsShip` from `@/types/ship` (the Zod-inferred type) and `ShipDocument` from `@/types/ship`.

**Field mapping (explicit, one-to-one):**

```
fleetyardsId     <- raw.id
slug             <- raw.slug
name             <- raw.name
scIdentifier     <- raw.scIdentifier ?? null
manufacturer     <- { name: raw.manufacturer.name, code: raw.manufacturer.code, slug: raw.manufacturer.slug }
classification   <- raw.classification ?? ''
classificationLabel <- raw.classificationLabel ?? ''
focus            <- raw.focus ?? ''
size             <- raw.size ?? ''
productionStatus <- raw.productionStatus ?? ''
crew             <- { min: raw.crew?.min ?? 0, max: raw.crew?.max ?? 0 }
cargo            <- raw.cargo ?? 0
length           <- raw.length ?? 0
beam             <- raw.beam ?? 0
height           <- raw.height ?? 0
mass             <- raw.mass ?? 0
scmSpeed         <- raw.scmSpeed ?? null
hydrogenFuelTankSize <- raw.hydrogenFuelTankSize ?? null
quantumFuelTankSize  <- raw.quantumFuelTankSize ?? null
pledgePrice      <- raw.pledgePrice ?? null
price            <- raw.price ?? null
description      <- raw.description ?? null
storeUrl         <- raw.storeUrl ?? null
```

**Image mapping:**
```
images.store            <- raw.storeImage ?? null
images.angledView       <- raw.angledView?.source ?? null
images.angledViewMedium <- raw.angledView?.medium ?? null
images.sideView         <- raw.sideView?.source ?? null
images.sideViewMedium   <- raw.sideView?.medium ?? null
images.topView          <- raw.topView?.source ?? null
images.topViewMedium    <- raw.topView?.medium ?? null
images.frontView        <- raw.frontView?.source ?? null
images.frontViewMedium  <- raw.frontView?.medium ?? null
images.fleetchartImage  <- raw.fleetchartImage ?? null
```

**Sync metadata:**
```
syncedAt              <- new Date()
syncVersion           <- syncVersion parameter
fleetyardsUpdatedAt   <- raw.updatedAt ?? raw.lastUpdatedAt ?? ''
updatedAt             <- new Date()
```

Note: `createdAt` is NOT set in the transform. It is set via `$setOnInsert` in the MongoDB upsert operation (handled by ship-storage.ts in Plan 03), so that it only gets set on first insert, never overwritten on update.

Do NOT use `any` type. Do NOT import from `@/lib/fleetyards/types` directly -- use the Zod-inferred type from `@/types/ship` since that's what the sync orchestrator will pass after validation.

Also export a helper:
```typescript
export function extractImageUrl(view: { source?: string; medium?: string } | null | undefined, size: 'source' | 'medium' = 'source'): string | null
```
This helper safely extracts an image URL from a view object, returning null if the view or the requested size is missing. Use this internally in the main transform for cleaner code.
  </action>
  <verify>
Run `npm run type-check` -- no type errors.
Verify the file exports `transformFleetYardsShip` and `extractImageUrl`.
Verify the return type omits `_id` and `createdAt` from ShipDocument.
  </verify>
  <done>transformFleetYardsShip() maps every FleetYards API field to the corresponding ShipDocument field with null-safe defaults. Images are extracted for store, angled, side, top, and front views in source and medium resolutions. createdAt is intentionally omitted (set by upsert $setOnInsert).</done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes with no errors from new files
2. `src/lib/fleetyards/client.ts` exports fetchAllShips
3. `src/lib/fleetyards/transform.ts` exports transformFleetYardsShip and extractImageUrl
4. client.ts imports FleetYardsShipResponse from ./types
5. transform.ts imports ShipDocument and ValidatedFleetYardsShip from @/types/ship
6. No hardcoded ship data -- all fields mapped from API response
</verification>

<success_criteria>
- FleetYards API client handles pagination, retry, rate limiting, and returns structured results
- Transform function maps every field explicitly (no spread operator on raw API data)
- Both files compile without type errors
- Client uses native fetch (not Axios)
- No new dependencies added (native fetch + inline delay)
</success_criteria>

<output>
After completion, create `.planning/phases/01-sync-engine-and-data-model/01-02-SUMMARY.md`
</output>
