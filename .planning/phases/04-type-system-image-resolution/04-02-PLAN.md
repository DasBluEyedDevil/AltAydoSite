---
phase: 04-type-system-image-resolution
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/lib/ships/image.ts
  - src/app/api/profile/route.ts
  - src/app/api/planned-missions/route.ts
autonomous: true

must_haves:
  truths:
    - "resolveShipImage() accepts a ShipImages object and view angle, returning a FleetYards CDN URL"
    - "resolveShipImage() falls back through angled -> store -> placeholder when requested view is unavailable"
    - "Legacy resolveShipImageLegacy() function is exported for existing component consumers until Phase 6"
    - "Profile API accepts ships with fleetyardsId and does not require image field"
    - "Planned missions API accepts ships with fleetyardsId and does not require image field"
    - "npm run type-check passes with no new errors"
  artifacts:
    - path: "src/lib/ships/image.ts"
      provides: "resolveShipImage(images, view), resolveShipImageLegacy(model), getShipPlaceholder(), ShipImageView type, ShipImages type"
      exports: ["resolveShipImage", "resolveShipImageLegacy", "getShipPlaceholder", "ShipImageView", "ShipImages"]
    - path: "src/app/api/profile/route.ts"
      provides: "Profile PUT endpoint accepting fleetyardsId in ship validation"
      contains: "fleetyardsId"
    - path: "src/app/api/planned-missions/route.ts"
      provides: "Planned missions validation accepting fleetyardsId instead of requiring image"
      contains: "fleetyardsId"
  key_links:
    - from: "src/lib/ships/image.ts"
      to: "ShipDocument.images"
      via: "ShipImages type matches ShipDocument.images shape"
      pattern: "angledView.*string.*null"
    - from: "src/app/api/profile/route.ts"
      to: "UserShip type"
      via: "Zod schema mirrors UserShip interface"
      pattern: "fleetyardsId.*z\\.string"
    - from: "src/app/api/planned-missions/route.ts"
      to: "MissionShip type"
      via: "validateMissionShips checks fleetyardsId"
      pattern: "ship\\.fleetyardsId"
---

<objective>
Rewrite the ship image resolution function to work from ShipDocument images (not ship name strings), and update API route validation to accept fleetyardsId-based ship data.

Purpose: The new resolveShipImage() enables Phase 5-6 components to render ship images from FleetYards CDN URLs stored in ShipDocument.images. The API validation updates prevent 400 errors when saving ships that have fleetyardsId but no image field (which is now optional per Plan 01 type changes). The legacy function is preserved as resolveShipImageLegacy() so existing components continue working until Phase 6 rewires them.

Output: Rewritten image resolution module, updated profile API validation, updated planned-missions API validation.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-type-system-image-resolution/04-RESEARCH.md
@.planning/phases/04-type-system-image-resolution/04-01-SUMMARY.md
@src/lib/ships/image.ts
@src/app/api/profile/route.ts
@src/app/api/planned-missions/route.ts
@src/types/ship.ts
@src/types/user.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite resolveShipImage with document-based resolution</name>
  <files>src/lib/ships/image.ts</files>
  <action>
Rewrite `src/lib/ships/image.ts` to replace the name-based resolution with document-based resolution from ShipDocument.images. Keep the legacy function available for existing consumers.

**New file structure:**

1. **Remove** the imports of `getDirectImagePath` and `getShipByName` from `@/types/ShipData` (these are legacy).

2. **Export ShipImageView type:**
```typescript
export type ShipImageView = 'angled' | 'side' | 'top' | 'front' | 'store' | 'fleetchart';
```

3. **Export ShipImages type** -- This must match the shape of `ShipDocument.images` from `src/types/ship.ts` exactly:
```typescript
export type ShipImages = {
  store: string | null;
  angledView: string | null;
  angledViewMedium: string | null;
  sideView: string | null;
  sideViewMedium: string | null;
  topView: string | null;
  topViewMedium: string | null;
  frontView: string | null;
  frontViewMedium: string | null;
  fleetchartImage: string | null;
};
```

4. **New resolveShipImage function:**
- Signature: `resolveShipImage(images: ShipImages | null | undefined, view: ShipImageView = 'angled'): string`
- If images is null/undefined, return `getShipPlaceholder()`
- Define a viewMap mapping each ShipImageView to an array of ShipImages keys to try (prefer full resolution, fall back to medium):
  - angled: ['angledView', 'angledViewMedium']
  - side: ['sideView', 'sideViewMedium']
  - top: ['topView', 'topViewMedium']
  - front: ['frontView', 'frontViewMedium']
  - store: ['store']
  - fleetchart: ['fleetchartImage']
- Try each candidate key for the requested view. Return first non-null/non-empty string.
- Fallback chain: if requested view not available AND view is not 'angled', try images.angledView. Then try images.store. Then return placeholder.

5. **Legacy function renamed:**
- Rename old function to `resolveShipImageLegacy`
- Keep the EXACT same implementation (imports from ShipData, name-based resolution)
- Add `@deprecated` JSDoc: `Use resolveShipImage(images, view) instead. Will be removed in Phase 7.`
- The legacy imports (`getDirectImagePath`, `getShipByName` from `@/types/ShipData`) move to only be used by this legacy function.

6. **getShipPlaceholder** stays unchanged: `return '/assets/ship-placeholder.png';`

**Important:** The legacy function MUST still work for existing components (ShipImage.tsx, UserFleetBuilder.tsx, MissionComposer.tsx) that call `resolveShipImage(modelName)`. Since we are RENAMING the old function, existing callers will get a compile error. But per the research, these components are deferred to Phase 6 for rewiring. So to avoid breaking type-check NOW, we need to check: do any of those components import `resolveShipImage` by name?

Check imports with: `grep -r "resolveShipImage" src/components/`

If components import `resolveShipImage` by name, we have two options:
- Option A: Keep old signature as an overload (complex, fragile)
- Option B: Rename old to `resolveShipImageLegacy` and update the 3 component import sites to use the new name

Choose Option B: update the import sites in the 3 component files to use `resolveShipImageLegacy`. This is a single-line change per file (rename the import). Do NOT change any other code in those components -- just the import name. This way type-check passes and Phase 6 does the full rewire.

If `grep` shows the components import `resolveShipImage`, update those imports to `resolveShipImageLegacy`. The files to check (and update if needed):
- `src/components/mission/ShipImage.tsx`
- `src/components/UserFleetBuilder.tsx`
- `src/components/fleet-ops/mission-planner/MissionComposer.tsx`
  </action>
  <verify>
1. `grep "resolveShipImage" src/lib/ships/image.ts` shows both `resolveShipImage` and `resolveShipImageLegacy` exported
2. `grep "ShipImageView" src/lib/ships/image.ts` shows the type export
3. `grep "ShipImages" src/lib/ships/image.ts` shows the type export
4. `npm run type-check` passes
  </verify>
  <done>
src/lib/ships/image.ts exports: resolveShipImage(images, view) for new document-based resolution, resolveShipImageLegacy(model) for backward compatibility, getShipPlaceholder(), ShipImageView type, ShipImages type. Existing component imports updated to resolveShipImageLegacy. npm run type-check passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update profile and planned-missions API validation for fleetyardsId</name>
  <files>
    src/app/api/profile/route.ts
    src/app/api/planned-missions/route.ts
  </files>
  <action>
Update both API routes to accept the new type shape where fleetyardsId is the primary identifier and image is optional.

**src/app/api/profile/route.ts:**

1. Update the Zod `userShipSchema` (lines 9-13):
```typescript
const userShipSchema = z.object({
  manufacturer: z.string(),
  name: z.string(),
  fleetyardsId: z.string().uuid(),
  image: z.string().optional(),
});
```
- `fleetyardsId` is required (z.string().uuid()) because UserShip type requires it
- `image` changes from `z.string()` to `z.string().optional()`

2. Update the manual ship validation in the ships-only update path (line 105):
Change:
```typescript
if (!ship.manufacturer || !ship.name || !ship.image) {
```
To:
```typescript
if (!ship.manufacturer || !ship.name || !ship.fleetyardsId) {
```
This matches the new type where fleetyardsId is required and image is optional.

**src/app/api/planned-missions/route.ts:**

1. Update `validateMissionShips` function (lines 82-93):
Change line 89:
```typescript
if (!ship.image || typeof ship.image !== 'string') return false;
```
To:
```typescript
if (!ship.fleetyardsId || typeof ship.fleetyardsId !== 'string') return false;
```
This validates that ships have a fleetyardsId (the new required field on MissionShip) instead of requiring image. Image is now optional on MissionShip per the Plan 01 type changes.

No other changes needed in these files. The rest of the validation logic (name, manufacturer, quantity for planned missions; other profile fields) stays the same.
  </action>
  <verify>
1. `grep "fleetyardsId" src/app/api/profile/route.ts` shows fleetyardsId in both Zod schema and manual validation
2. `grep "fleetyardsId" src/app/api/planned-missions/route.ts` shows fleetyardsId in validateMissionShips
3. `grep "image" src/app/api/profile/route.ts` shows image as optional in Zod schema
4. `npm run type-check` passes
  </verify>
  <done>
Profile API Zod schema requires fleetyardsId (UUID) and makes image optional. Manual ship validation checks fleetyardsId instead of image. Planned missions validateMissionShips checks fleetyardsId instead of image. npm run type-check passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes with exit code 0
2. `grep -c "resolveShipImageLegacy" src/lib/ships/image.ts` returns at least 1 (legacy export exists)
3. `grep "fleetyardsId.*uuid" src/app/api/profile/route.ts` returns a match (Zod validates UUID format)
4. `grep "ship.fleetyardsId" src/app/api/planned-missions/route.ts` returns a match
5. `grep "ShipImageView" src/lib/ships/image.ts` returns a match (type exported)
6. No component files were modified beyond import renames (verify with `git diff --stat` on component files showing only import line changes)
</verification>

<success_criteria>
- resolveShipImage(images, view) accepts ShipImages object and returns CDN URL with angled->store->placeholder fallback chain
- resolveShipImageLegacy(model) preserves old name-based resolution for existing components
- ShipImageView and ShipImages types are exported from src/lib/ships/image.ts
- Profile API accepts {manufacturer, name, fleetyardsId, image?} and rejects ships without fleetyardsId
- Planned missions API accepts ships with fleetyardsId and does not require image
- Existing component imports updated from resolveShipImage to resolveShipImageLegacy (import rename only)
- npm run type-check passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-type-system-image-resolution/04-02-SUMMARY.md`
</output>
