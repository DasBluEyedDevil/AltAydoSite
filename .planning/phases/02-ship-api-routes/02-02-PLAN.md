---
phase: 02-ship-api-routes
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/api/ships/route.ts
  - src/app/api/ships/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/ships returns a paginated ship list filtered by any combination of manufacturer, size, classification, production status, and text search"
    - "GET /api/ships/[id] returns a single ship when given a FleetYards UUID"
    - "GET /api/ships/[id] returns a single ship when given a slug"
    - "GET /api/ships/[id] returns 404 when the ship does not exist"
    - "Both endpoints return responses without requiring authentication"
    - "Both endpoints set Cache-Control headers for public caching"
  artifacts:
    - path: "src/app/api/ships/route.ts"
      provides: "GET /api/ships endpoint with Zod-validated query params"
      exports: ["GET"]
    - path: "src/app/api/ships/[id]/route.ts"
      provides: "GET /api/ships/[id] endpoint with UUID-or-slug detection"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/ships/route.ts"
      to: "src/lib/ship-storage.ts"
      via: "findShips() function call"
      pattern: "shipStorage\\.findShips"
    - from: "src/app/api/ships/[id]/route.ts"
      to: "src/lib/ship-storage.ts"
      via: "getShipByIdOrSlug() function call"
      pattern: "shipStorage\\.getShipByIdOrSlug"
---

<objective>
Create the ship list and single ship lookup API routes (API-01 and API-02).

Purpose: These are the two most critical ship API endpoints. The list endpoint enables browsing/searching the entire ship database. The single ship endpoint enables detail views and direct linking by UUID or slug.

Output: Two Next.js App Router route files implementing GET /api/ships and GET /api/ships/[id].
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ship-api-routes/02-RESEARCH.md
@.planning/phases/02-ship-api-routes/02-01-SUMMARY.md

@src/lib/ship-storage.ts
@src/app/api/users/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GET /api/ships route (API-01)</name>
  <files>src/app/api/ships/route.ts</files>
  <action>
Create `src/app/api/ships/route.ts` with a single GET handler.

**Imports:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import * as shipStorage from '@/lib/ship-storage';
```

**Zod query schema** (define at top of file, outside handler):
```typescript
const ShipListQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  pageSize: z.coerce.number().int().min(1).max(100).default(25),
  manufacturer: z.string().optional(),
  size: z.string().optional(),
  classification: z.string().optional(),
  productionStatus: z.string().optional(),
  search: z.string().min(1).optional(),
});
```

**GET handler:**
1. Extract `searchParams` from `new URL(request.url)`
2. Convert searchParams to a plain object by iterating `searchParams.forEach((value, key) => rawParams[key] = value)`
3. Parse with `ShipListQuerySchema.safeParse(rawParams)`
4. If parse fails, return 400 with `{ error: 'Invalid query parameters', details: parseResult.error.errors.map(e => \`${e.path.join('.')}: ${e.message}\`) }`
5. Call `shipStorage.findShips(parseResult.data)` and return the result directly as JSON
6. Set `Cache-Control: public, max-age=300, stale-while-revalidate=60` on the response
7. Wrap in try/catch. On error, log with `[ships]` prefix, return 500 with `{ error: message }`

**No authentication required.** Ship data is public reference data. Do NOT import getServerSession or authOptions.

Follow the existing route pattern from `/api/users/route.ts` for structure and error handling style, but use Zod for parameter validation instead of manual parseInt.
  </action>
  <verify>
Run `npm run type-check` to confirm no TypeScript errors. Verify the file exports a GET function.
  </verify>
  <done>
GET /api/ships route exists, accepts page/pageSize/manufacturer/size/classification/productionStatus/search query params, validates with Zod, delegates to shipStorage.findShips, returns paginated response with Cache-Control header, no auth required.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/ships/[id] route (API-02)</name>
  <files>src/app/api/ships/[id]/route.ts</files>
  <action>
Create `src/app/api/ships/[id]/route.ts` with a single GET handler.

**Imports:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import * as shipStorage from '@/lib/ship-storage';
```

**GET handler** (Next.js App Router dynamic route receives params as second argument):

Function signature:
```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
```

Note: In Next.js 15, dynamic route params are a Promise and must be awaited. Use `const { id } = await params;`.

Implementation:
1. Await and destructure `id` from params
2. Validate `id` is a non-empty string. If empty, return 400 with `{ error: 'Ship ID or slug is required' }`
3. Call `shipStorage.getShipByIdOrSlug(id)` -- this function (from Plan 01) handles UUID-vs-slug detection internally
4. If result is null, return 404 with `{ error: 'Ship not found' }`
5. Return the ship document as JSON with 200 status
6. Set `Cache-Control: public, max-age=300, stale-while-revalidate=60`
7. Wrap in try/catch. On error, log with `[ships]` prefix, return 500

**No authentication required.** No Zod needed here -- the only input is the URL param which is a simple string.

**No query parameters.** This endpoint returns the full ship document, no projections or field selection.
  </action>
  <verify>
Run `npm run type-check` to confirm no TypeScript errors. Verify the file exports a GET function.
  </verify>
  <done>
GET /api/ships/[id] route exists, accepts UUID or slug as the dynamic segment, delegates to shipStorage.getShipByIdOrSlug, returns 200 with ship data or 404 if not found, includes Cache-Control header, no auth required.
  </done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes with no errors related to the new route files
2. `src/app/api/ships/route.ts` exists and exports GET
3. `src/app/api/ships/[id]/route.ts` exists and exports GET
4. Neither route imports auth-related modules
5. Both routes set Cache-Control headers
6. Ship list route uses Zod validation for query params
</verification>

<success_criteria>
- GET /api/ships validates query params with Zod and returns paginated, filtered results
- GET /api/ships/[id] accepts UUID or slug and returns single ship or 404
- Both endpoints are public (no auth)
- Both endpoints set Cache-Control: public, max-age=300
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-ship-api-routes/02-02-SUMMARY.md`
</output>
