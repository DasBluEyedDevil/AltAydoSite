---
phase: 02-ship-api-routes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ship-storage.ts
  - src/lib/mongo-indexes.ts
autonomous: true

must_haves:
  truths:
    - "Ship data can be queried with text search, field filters, and pagination at the database level"
    - "A ship can be looked up by either FleetYards UUID or slug through a single function"
    - "Multiple ships can be resolved from an array of FleetYards UUIDs in one database round-trip"
    - "Distinct manufacturers can be aggregated from the ships collection with ship counts"
    - "A weighted text index exists on name and manufacturer.name for search relevance"
  artifacts:
    - path: "src/lib/ship-storage.ts"
      provides: "findShips, getShipByIdOrSlug, getShipsByFleetyardsIds, getManufacturers query functions"
      exports: ["findShips", "getShipByIdOrSlug", "getShipsByFleetyardsIds", "getManufacturers"]
    - path: "src/lib/mongo-indexes.ts"
      provides: "Text index on ships.name + ships.manufacturer.name"
      contains: "name: 'text'"
  key_links:
    - from: "src/lib/ship-storage.ts"
      to: "src/lib/mongodb-client.ts"
      via: "connectToDatabase() singleton"
      pattern: "connectToDatabase"
    - from: "src/lib/ship-storage.ts"
      to: "src/types/ship.ts"
      via: "ShipDocument type import"
      pattern: "import.*ShipDocument.*from.*types/ship"
---

<objective>
Extend the ship storage module with query functions and add a text search index to support the four Phase 2 API endpoints.

Purpose: The API route handlers (Plans 02 and 03) need database query functions that push filtering, pagination, and search to MongoDB rather than fetching all documents and filtering in JavaScript. This plan creates those functions and the text index they depend on.

Output: Extended `ship-storage.ts` with four new exported functions and `mongo-indexes.ts` with a weighted text index on ships.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ship-api-routes/02-RESEARCH.md

@src/lib/ship-storage.ts
@src/lib/mongo-indexes.ts
@src/types/ship.ts
@src/lib/mongodb-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add query functions to ship-storage.ts</name>
  <files>src/lib/ship-storage.ts</files>
  <action>
Add four new exported functions to the existing ship-storage.ts module, below the existing CRUD operations section. Add a new section header comment `// Ship Query Operations`.

**1. `findShips(options: ShipQueryOptions): Promise<ShipQueryResult>`**

Define interfaces at the top of the new section:

```typescript
export interface ShipQueryOptions {
  page: number;
  pageSize: number;
  manufacturer?: string;     // filter by manufacturer.slug
  size?: string;             // filter by size field
  classification?: string;   // filter by classification field
  productionStatus?: string; // filter by productionStatus field
  search?: string;           // $text search on name + manufacturer.name
}

export interface ShipQueryResult {
  items: ShipDocument[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}
```

Implementation:
- Build a `filter` object (`Record<string, unknown>`)
- If `search` is provided, add `filter.$text = { $search: search }`
- If `manufacturer` is provided, add `filter['manufacturer.slug'] = manufacturer`
- If `size` is provided, add `filter.size = size`
- If `classification` is provided, add `filter.classification = classification`
- If `productionStatus` is provided, add `filter.productionStatus = productionStatus`
- Sort: if search is provided, sort by `{ score: { $meta: 'textScore' } }`; otherwise sort by `{ name: 1 }`
- Projection: always include `{ _id: 0 }`; if search is provided, also include `{ score: { $meta: 'textScore' } }`
- Use `skip((page - 1) * pageSize)` and `.limit(pageSize)` to push pagination to MongoDB
- Run `find()` and `countDocuments(filter)` in parallel with `Promise.all`
- Return `{ items, total, page, pageSize, totalPages: Math.ceil(total / pageSize) || 1 }`
- Wrap in try/catch. On `$text` query failure, implement fallback: catch the error, log `[ship-storage] $text query failed, falling back to $regex`, rebuild filter replacing `$text` with `{ name: { $regex: search, $options: 'i' } }`, re-run the query with sort `{ name: 1 }` (no textScore in fallback). This handles the case where the text index did not create successfully.

**2. `getShipByIdOrSlug(idOrSlug: string): Promise<ShipDocument | null>`**

- Define `const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;` at module level (top of file, after imports)
- If `UUID_REGEX.test(idOrSlug)`, delegate to existing `getShipByFleetyardsId(idOrSlug)`
- Otherwise, delegate to existing `getShipBySlug(idOrSlug)`

**3. `getShipsByFleetyardsIds(ids: string[]): Promise<ShipDocument[]>`**

- If `ids.length === 0`, return `[]`
- Query with `{ fleetyardsId: { $in: ids } }` and projection `{ _id: 0 }`
- Return results as `ShipDocument[]`
- Wrap in try/catch, log errors with `[ship-storage]` prefix, return `[]` on failure

**4. `getManufacturers(): Promise<ManufacturerInfo[]>`**

Define interface:
```typescript
export interface ManufacturerInfo {
  name: string;
  code: string;
  slug: string;
  shipCount: number;
}
```

- Use MongoDB aggregation pipeline:
  1. `$group` by `$manufacturer.slug`, with `$first` for name, code, slug, and `$sum: 1` for shipCount
  2. `$sort` by `{ name: 1 }`
  3. `$project` with `{ _id: 0, name: 1, code: 1, slug: 1, shipCount: 1 }`
- Return results as `ManufacturerInfo[]`
- Wrap in try/catch, log errors, return `[]` on failure

Follow the existing code style in ship-storage.ts: JSDoc comments on every function, `[ship-storage]` log prefix, try/catch with console.error.
  </action>
  <verify>
Run `npm run type-check` to confirm TypeScript compiles without errors. Verify the four new functions are exported by checking the file.
  </verify>
  <done>
ship-storage.ts exports findShips, getShipByIdOrSlug, getShipsByFleetyardsIds, and getManufacturers. All functions compile without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add text index to mongo-indexes.ts</name>
  <files>src/lib/mongo-indexes.ts</files>
  <action>
In the existing `ensureMongoIndexes` function, find the `ships` index block (the `try` block that creates indexes on the `ships` collection). Add a weighted text index for search:

```typescript
ships.createIndex(
  { name: 'text', 'manufacturer.name': 'text' },
  { weights: { name: 10, 'manufacturer.name': 5 }, name: 'ships_text_search' }
).catch(err => console.warn('[mongo-indexes] Ships text index creation failed:', err)),
```

Add this to the existing `Promise.all([...])` array inside the ships try block, after the existing indexes.

IMPORTANT: Do NOT use the generic `.catch(() => {})` swallower used by other indexes. Use `.catch(err => console.warn(...))` with the specific error message so text index failures are visible in logs. This is a critical index for search functionality -- silent failures would cause hard-to-debug runtime errors (Pitfall 1 from research).

Also add a `classification` index since the API filters by classification and there is no existing index for it:

```typescript
ships.createIndex({ classification: 1 }).catch(() => {}),
```

And a `size` index for the same reason:

```typescript
ships.createIndex({ size: 1 }).catch(() => {}),
```

These support the filter fields used by findShips(). The existing compound index on `manufacturer.code + size` covers manufacturer+size combos but not standalone size or classification queries.
  </action>
  <verify>
Run `npm run type-check` to confirm TypeScript compiles. Inspect the file to verify the text index line includes the weights option and the warn-level catch handler.
  </verify>
  <done>
mongo-indexes.ts creates a weighted text index on ships.name + manufacturer.name with weights { name: 10, manufacturer.name: 5 }, plus standalone classification and size indexes. Text index failures are logged with a warning (not silently swallowed).
  </done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes with no errors related to ship-storage.ts or mongo-indexes.ts
2. ship-storage.ts exports: findShips, getShipByIdOrSlug, getShipsByFleetyardsIds, getManufacturers (plus all existing exports unchanged)
3. mongo-indexes.ts ships block includes text index with weights and warn-level error logging
4. No changes to existing function signatures or behavior
</verification>

<success_criteria>
- Four new query functions are exported from ship-storage.ts with proper TypeScript types
- findShips supports text search with $regex fallback for resilience
- Text index is configured with name weighted 10x and manufacturer.name weighted 5x
- All existing ship-storage.ts and mongo-indexes.ts functionality is preserved
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-ship-api-routes/02-01-SUMMARY.md`
</output>
